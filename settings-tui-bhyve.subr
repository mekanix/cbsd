# BHYVE-related TUI function
if [ ! "$_CBSD_SETTINGS_TUI_BHYVE_SUBR" ]; then
_CBSD_SETTINGS_TUI_BHYVE_SUBR=1
###

# bhyve form for $bhyve_flags
get_construct_bhyve_flags()
{
	title=" additioal bhyve_flags "
	prompt="enter additional bhyve(8) args"
	defaultitem="${bhyve_flags}"

	cbsd_inputbox_simple && bhyve_flags="${mtag}"
}

# bhyve form for $bhyve_vnc_vgaconf
get_construct_bhyve_vnc_vgaconf_menu()
{
	local _input _res

	# for default values
	readconf vnc.conf

	local title="VGACONF setting"
	local defaultitem="${bhyve_vnc_vgaconf}"

	local menu_list="
		'io'	'io'	'I/O port queries'
		'on'	'on'	'for legacy VGA I/O and memory regions'
		'off'	'off'	'VGA adapter is present if they detect the I/O ports'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && bhyve_vnc_vgaconf="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}

}

# bhyve form for $debug_engine
get_construct_debug_engine()
{
	local _input _res

	local title="Debug engine"
	local defaultitem="${debug_engine}"

	local menu_list="
		'gdb'	'gdb'	'GNU debugger'
		'lldb'	'lldb'	'LLVM debuger'
		'none'	'none'	'No debuger'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && debug_engine="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# bhyve form for $vm_hostbridge
get_construct_vm_hostbridge()
{
	local _input _res

	local title="${GET_HOSTBRIDGE_MSG}"
	local defaultitem="${vm_hostbridge}"

	local menu_list="
		'hostbridge'		'hostbridge'		'Provide a simple host bridge.'
		'amd_hostbridge'	'amd_hostbridge'	'The amd_hostbridge emulation is identical but uses a PCI vendor ID of AMD'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_hostbridge="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# bhyve form for $vnc_resolution
get_construct_bhyve_vnc_resolution_menu()
{
	local _input _res

	# for default values
	readconf vnc.conf

	local title="VNC Resolution"
	local defaultitem="${bhyve_vnc_resolution}"

	local menu_list="
		'640x480'		'640 x 480'		'640 x 480'
		'800x600'		'800 x 600'		'800 x 600'
		'1024x768'		'1024 x 768'		'1024 x 768'
		'1280x720'		'1280 x 720'		'1280 x 720'
		'1280x1024'		'1280 x 1024'		'1280 x 1024'
		'1600x900'		'1600 x 900'		'1600 x 900'
		'1600x1200'		'1600 x 1200'		'1600 x 1200'
		'1920x1080'		'1920 x 1080'		'1920 x 1080'
		'1920x1200'		'1920 x 1200'		'1920 x 1200'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && bhyve_vnc_resolution="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# bhyve form for bhyve options
get_construct_bhyve_options_menu()
{
	local _input _res item_let=A

	local title="Additional bhyve arguments"
	local defaultitem=
	local menu_choice=
	local _checkbox="bhyve_generate_acpi bhyve_wire_memory bhyve_rts_keeps_utc bhyve_force_msi_irq bhyve_x2apic_mode bhyve_mptable_gen bhyve_ignore_msr_acc"

	f_dialog_default_fetch defaultitem

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} bhyve_generate_acpi'		'[${bhyve_generate_acpi_mark}]'		'Generate ACPI tables.  Required for FreeBSD/amd64 guests'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_wire_memory'			'[${bhyve_wire_memory_mark}]'		'Wire guest memory'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_rts_keeps_utc'		'[${bhyve_rts_keeps_utc_mark}]'		'RTC keeps UTC time'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_force_msi_irq'		'[${bhyve_force_msi_irq_mark}]'		'Force virtio PCI device to use MSI interrupts instead of MSI-X'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_x2apic_mode'			'[${bhyve_x2apic_mode_mark}]'		'The guests local APIC is configured in x2APIC mode'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_mptable_gen'			'[${bhyve_mptable_gen_mark}]'		'Disable MPtable generation'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_ignore_msr_acc'		'[${bhyve_ignore_msr_acc_mark}]'	'Ignore accesses to unimplemented MSRs'"

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}

# bhyve form for bhyve vnc options
get_construct_bhyve_vnc_options_menu()
{
	local _input _res item_let=A

	local title="VNC Options"
	local defaultitem=
	local menu_choice=
	local _checkbox="cd_vnc_wait"

	f_dialog_default_fetch defaultitem

	readconf vnc.conf
	[ -z "${bhyve_vnc_resolution}" ] && bhyve_vnc_resolution="${default_vnc_width}x${default_vnc_height}"
	[ -z "${bhyve_vnc_tcp_bind}" ] && bhyve_vnc_tcp_bind="${default_vnc_tcp_bind}"
	[ -z "${bhyve_vnc_vgaconf}" ] && bhyve_vnc_vgaconf="${default_bhyve_vnc_vgaconf}"

	if [ "${vnc_password}" = "0" ]; then
		unset vnc_password
	else
		[ -z "${vnc_password}" ] && vnc_password="${default_vnc_password}"
	fi

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} cd_vnc_wait'		'[${cd_vnc_wait_mark}]'		'When booting from CD - wait for connections on VNC before VM run'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_vnc_resolution'	'[${bhyve_vnc_resolution}]'	'Default: width - ${default_vnc_width}, height - ${default_vnc_height}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_vnc_tcp_bind'	'[${bhyve_vnc_tcp_bind}]'	'Default: ${default_vnc_tcp_bind}'"

	# vgaconf support introduced in FreeBSD 11.1+

	if [ ${freebsdhostversion} -gt 1101000 ]; then
		inc_menu_index item_let
		menu_list="${menu_list} '${item_let} bhyve_vnc_vgaconf'		'[${bhyve_vnc_vgaconf}]'	'Default: ${bhyve_default_vnc_vgaconf}'"
	fi

	# VNC password support introduced in FreeBSD 11.1
	if [ ${freebsdhostversion} -gt 1101000 ]; then
		inc_menu_index item_let
		menu_list="${menu_list} '${item_let} vnc_password'		'[${vnc_password}]'		'Default: see vnc.conf file'"
	fi

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}

# bhyve form for bhyve options
get_construct_bhyve_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_bhyve_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"
}

# bhyve form for bhyve vnc options
get_construct_bhyve_vnc_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_bhyve_vnc_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		bhyve_vnc_tcp_bind)
			title=" vnc bind "
			prompt="default via vnc.conf: ${default_vnc_tcp_bind}\nUse 0.0.0.0 for all IPs"
			defaultitem="${bhyve_vnc_tcp_bind}"
			cbsd_inputbox_simple && bhyve_vnc_tcp_bind="${mtag}"
			;;
		bhyve_vnc_resolution)
			get_construct_bhyve_vnc_resolution_menu
			;;
		bhyve_vnc_vgaconf)
			get_construct_bhyve_vnc_vgaconf_menu
			;;
		vnc_password)
			get_construct_vnc_password
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"
}

# bhyve form for $vm_efi
get_construct_vm_efi()
{
	local _input _res

	local title="${GET_EFI_MSG}"
	local defaultitem="${vm_efi}"

	local menu_list="
		'none'		'No UEFI boot'	'Legacy boot mode'
		'uefi'		'UEFI'		'Boot using UEFI firmware'
		'uefi_csm'	'UEFI CSM'	'Boot using UEFI CSM firmware'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_efi="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# bhyve form for $vm_console
get_construct_vm_console()
{
	local _input _res

	local title="${GET_CONSOLE_MSG}"
	local defaultitem="${vm_console}"

	local menu_list="
		'tmux'		'tmux console'			'No serial, just tmux session'
		'nmdm'		'serial console via nmdm'	'Serial console via nullmodem driver'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_console="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# bhyve form for $cd_boot_firmware
get_construct_cd_boot_firmware()
{
	local _input _res

	local title="${GET_CD_BOOT_FIRMWARE_MSG}"
	local defaultitem="${cd_boot_firmware}"

	local menu_list="
		'bhyve'		'standard bhyve firmware'	'No serial, just tmux session'
		'refind'	'reFIND firmware'		'reFIND firmware'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && cd_boot_firmware="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# bhyve jconf part
make_bhyve_part()
{
	local i _val

	if [ -n "${alt_iso}" ]; then
		iso_site=
		iso_img=
		iso_img_type=
		register_iso_name=
		register_iso_as="${alt_iso}";		# vm_os_path
	fi

/bin/cat >> ${TMPFILE} << EOF
# Bhyve minimal configuration:
#jname="${jname}";
# first disk size
imgsize="${imgsize}";
# number of vcpu
vm_cpus="${vm_cpus}";
# ram amount
vm_ram="${vm_ram}";
# profile os type
vm_os_type="${vm_os_type}";
# vm defaults/setting profile
vm_os_profile="${vm_os_profile}";
# end of Bhyve minimal configuration

#exec_start="${exec_start}"
#exec_stop="${exec_stop}"
emulator="bhyve";
# disk type - md or zvol
imgtype="${imgtype}";
# efi boot?
vm_efi="${vm_efi}";
# source site's for iso
iso_site="${iso_site}";
# iso image filename
iso_img="${iso_img}";
# iso image type?
iso_img_type="${iso_img_type}";
# register ISO as name
register_iso_name="${register_iso_name}"
# register ISO as 
register_iso_as="${register_iso_as}"
# vm hostbridge
vm_hostbridge="${vm_hostbridge}";
# additional bhyve flags
bhyve_flags="${bhyve_flags}";
# first disk type
virtio_type="${virtio_type}";
# swap size for vm-from-jail
swapsize="${swapsize}";
# path to iso image
vm_iso_path="${register_iso_as}";
# guest fs for vm-from-jail
vm_guestfs="${vm_guestfs}";
# VNC port
vm_vnc_port="${vm_vnc_port}";
# bhyve flags
bhyve_generate_acpi="${bhyve_generate_acpi}";
# bhyve flags
bhyve_wire_memory="${bhyve_wire_memory}";
# bhyve flags
bhyve_rts_keeps_utc="${bhyve_rts_keeps_utc}";
# bhyve flags
bhyve_force_msi_irq="${bhyve_force_msi_irq}";
# bhyve flags
bhyve_x2apic_mode="${bhyve_x2apic_mode}";
# bhyve flags
bhyve_mptable_gen="${bhyve_mptable_gen}";
# bhyve flags
bhyve_ignore_msr_acc="${bhyve_ignore_msr_acc}";
# wait for VNC connect when boot from CD 
cd_vnc_wait="${cd_vnc_wait}";
# VNC resolution
bhyve_vnc_resolution="${bhyve_vnc_resolution}";
# VNC bind addr
bhyve_vnc_tcp_bind="${bhyve_vnc_tcp_bind}";
# vgaconf settings
bhyve_vnc_vgaconf="${bhyve_vnc_vgaconf}";
# first NIC driver
nic_driver="${nic_driver}";
# password for VNC
vnc_password='${vnc_password}';
# automatically eject CD when boot from CD and hard-disk is not empty
media_auto_eject="${media_auto_eject}";
# cpu topology name
vm_cpu_topology="${vm_cpu_topology}";
# run via debugger
debug_engine="${debug_engine}";
# emulate xhci
xhci="${xhci}";
# use alternative boot firmware
cd_boot_firmware="${cd_boot_firmware}";
# jailed bhyve ?
jailed="${jailed}";
# custom behavior settings by exit codes
on_poweroff="${on_poweroff}";
# custom behavior settings by exit codes
on_reboot="${on_reboot}";
# custom behavior settings by exit codes
on_crash="${on_crash}";
# is cloud image?
is_cloud='${is_cloud}';
EOF

	[ ${is_cloud} -eq 0 ] && return 0
	# todo: make is generic make_cloud_init_part()
/bin/cat >> ${TMPFILE} << EOF
# cloud-init settings
ci_jname='${ci_jname}';
ci_fqdn='${ci_fqdn}';
ci_template='${ci_template}';
ci_user_pw_root_crypt='${ci_user_pw_root_crypt}';
ci_interface='${ci_interface}';
ci_ip4_addr='${ci_ip4_addr}';
ci_gw4='${ci_gw4}';
ci_nameserver_address='${ci_nameserver_address}';
ci_nameserver_search='${ci_nameserver_search}';
ci_adjust_inteface_helper='${ci_adjust_inteface_helper}';
ci_user_add='${ci_user_add}';
ci_user_pubkey='${ci_user_add}';
EOF

for i in ${ci_user_add}; do
	for _par in gecos home shell member_groups pubkey; do
		_val=
		eval _val="\$ci_user_${_par}_${i}"
		/bin/cat >> ${TMPFILE} << EOF
ci_user_${_par}_${i}='${_val}';
EOF
	done
done
}

###
fi
