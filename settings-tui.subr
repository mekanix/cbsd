if [ ! "$_CBSD_SETTINGS_TUI_SUBR" ]; then
_CBSD_SETTINGS_TUI_SUBR=1
###

#required for . ${dialog} 
TMPFILE="${ftmpdir}/inputbox.$$"

jname_msg="Jail name. Name must begin with a letter / a-z /  and not have any special symbols: -,.=%"
host_hostname_msg="Jail Fully Qualified Domain Name"
ip4_addr_msg="Jail IPv4 and/or IPv6 address. Current CBSD IPv4 pool: ${nodeippool}\n\
 Use IP/PREFIX form, comma-separated for aliases.\n\
 '0' to disable IP creating by CBSD (useful for vnet jails)\n\
 'DHCP' for determine free IPv4 automatically\n\
 'nic1#ip_addr,nic2#ip_addr' for multiple NIC form\n"
interface_msg="Auto create and auto remove IP on selected NICs. 0 for disable, auto - for auto detect"
ver_msg="Jail base source version"
basename_msg="Alternative jailbase name"
zfs_snapsrc_msg="Use this ZFS snapshot as source for jail data, e.g zmirror/jails/jail1@init"
path_msg="Mount point for Jail"
data_msg="Data directory for Jail"
devfs_ruleset_msg="DEVFS ruleset number for Jail devfs"
arch_msg="Target architecture, i386/amd64 or qemu-users arch"
baserw_msg="1,yes - Jail have personal copy of base system with write access, no NULLFS mount. 0,no - read-only and NULLFS"
mount_src_msg="1,yes - Jail have shared /usr/src tree in read-only"
kernelmount_msg="1,yes - Jail have mounted /boot/kernel tree in read-only. Usefull for DTRACE stuff in Jail"
mount_obj_msg="1,yes - Jail have mounted /usr/obj tree in read-only"
mount_ports_msg="1,yes - Jail have /usr/ports /usr/ports tree in read-only"
applytpl_msg="1,yes - Apply CBSD templates for Jail environment"
floatresolv_msg="1,yes - Floating /etc/resolv.conf content"
astart_msg="1,yes - Automatically start Jail when system boot"
vnet_msg="1.yes - Enable VIMAGE/VNet feature"
exec_timeout_msg="The maximum amount of time to wait for a command to complete"
exec_fib_msg="The FIB routing table to set when running commands inside the prison"
exec_consolelog_msg="Jail consolelog file for stdout/stderr output. Possible values: path_to_file, 0 - for disable log to file, 1 - for automatic $logdir/jname.log"
stop_timeout_msg="The maximum amount of time to wait for a jailed processes to exit after sending them a SIGTERM signal"
allow_dying_msg="Allow making changes to a dying Jail"
depend_msg="Specify a Jail or jails that this jail depends on"
allow_zfs_msg="Privileged users inside the jail will be able to mount and unmount the ZFS file system"
protected_msg="Prevent modification or deletion of a environment. 1 - protect/lock"
hidden_msg="Invisible environment flag. 1 - hide environment for frontend"
allow_kmem_msg="Allow kmem and /dev/io devices for jail. Warning: this is insecure options. Use it only for private purposes/X-jails"
allow_mount_msg="Allow privileged users inside the jail mount and unmount file system"
allow_devfs_msg="Allow privileged users inside the jail mount and unmount DEVFS file system"
mount_devfs_msg="Mount DEVFS filesystem in the jail"
mkhostsfile_msg="Automatically set IP/NAME in /etc/hosts when jail started"
allow_nullfs_msg="Allow privileged users inside the jail mount and unmount NULLFS file system"
allow_fusefs_msg="Allow privileged users inside the jail mount and unmount fuse-based file systems."
allow_raw_sockets_msg="The jail root is allowed to create raw sockets"
allow_tmpfs_msg="Allow privileged users inside the jail mount and unmount TMPFS file system"
allow_procfs_msg="Allow privileged users inside the jail mount and unmount PROCFS file system"
allow_reserved_ports_msg="Allow the jail root may bind to ports lower than 1024. For FreeBSD 11.1+"
childrenmax_msg="Enable hierarchical jails and set limit max children"
persist_msg="Allows a jail to exist without any processes."
enforce_statfs_msg="This determines what information processes in a jail are able to get about mount points"
allow_fdescfs_msg="Jail may mount the fdescfs file system"
allow_sysvipc_msg="Jail may use SYSV IPC (separated for FreeBSD 11.0+)"
allow_read_msgbuf_msg="Allow an unprivileged user to read the kernel message buffer"
mount_fdescfs_msg="Mount a FDESCFS filesystem on the chrooted /dev/fd directory"
cpuset_msg="Associate group of CPUs to jail. 0 - for all cores, See man 1 cpuset for valid value"
mdsize_msg="Enter size for the images"
jdomain_msg="Specify CBSD node group name for jail"
GET_NODENAME_MSG="Change nodename. Warning: this operation will recreate the ssh keys in $workdir/.ssh dir"
GET_IMGSIZE_MSG="Allocate X size of image free space: 100m, 1g"
GET_SWAPSIZE_MSG="Configure swap partitional in X size (usual RAMx2), 0 - for disable, e.g: 4g"
GET_CPUS_MSG="Number of CPUs: 1, max: 16"
GET_VM_VNC_PORT_MSG="VNC port. 0 - for auto, 1 - disable"
GET_RAM_MSG="RAM in MB, eg: 512, 1024M, 2g"
GET_VMPROFILE_MSG="Select profile for VMs"
GET_JAILPROFILE_MSG="Profile for jcreate"
GET_HOSTBRIDGE_MSG="Hostbridge for VMs, eg: hostbridge or amd_hostbridge"
GET_ALLOW_SYSVIPC_MSG="Select SYSVIPC behaviour"
GET_ALLOW_READ_MSGBUF_MSG="Select READ_MSGBUF behaviour"
GET_GUESTFS_MSG="Choose FS for boot image"
GET_EFI_MSG="Choose UEFI firmware"
GET_VM_PACKAGE_MSG="Choose package name"
GET_CONSOLE_MSG="Choose default console"
GET_IMGTYPE_MSG="Choose image type"
GET_ISOPATH_MSG="Path to ISO image in srcdir/iso, eg: release.iso. 0 - for default img_iso"
GET_VM_ISOPATH_MSG="Select available/registered ISO"
GET_VM_CPU_TOPOLOGY_MSG="Select CPU topology profile name"

GET_GW4_MSG="Enter default gateway inside VMs or jail"


# show [] * for empty $1 values
# for Option list from -tui
curval()
{
	local T
	[ -z "${1}" ] && return 0

	eval T="\$$1"
	if [ -n "${T}" ]; then
		printf "${T}"
	else
		printf " "
	fi
	return 0
}

# Increment index for menu counter
# required cbsd as shell for is_number
inc_menu_index()
{
	local T
	[ -z "${1}" ] && return 0

	eval T="\$$1"

	if ! is_number ${T}; then
		T=$(( T + 1 ))
	else
		T=$( echo ${T} | /usr/bin/tr '[ABCDEFGHIJKLMNOPQRSTUVWXYZ]' '[BCDEFGHIJKLMNOPQRSTUVWXYZA]' )
	fi
	eval "${1}=${T}"
	return 0
}

# form for $pkglist
get_construct_pkglist()
{
	local _i

	[ -z "${pkglist}" -o "${pkglist}" = "NO" ] && pkglist="${ftmpdir}/tui.$$"

	# load pkg list from profile
	if [ -n "${tpl_pkglist}" ]; then
		if [ -r "${tpl_pkglist}" ]; then
			/bin/cat ${tpl_pkglist} >> ${pkglist}
		else
			for _i in ${tpl_pkglist}; do
				echo ${_i} >> ${pkglist}
			done
		fi
	fi

	pkgbrowser controlmaster="${pkglist}"
	[ ! -s "${pkglist}" ] && pkglist="NO"
}

# form for $srvlist
get_construct_services()
{
	srvlist="${ftmpdir}/srv.$$"
	srvbrowser controlmaster="${srvlist}" baseonly=1
	[ ! -s "${srvlist}" ] && srvlist="NO"
}

# form for $srvlist
get_construct_add_user()
{
	adduser="${ftmpdir}/adduser.$$"
	adduser-tui controlmaster="${adduser}"
	[ ! -s "${adduser}" ] && adduser=
}

# form for $jname
# if $1 = "nosearch" than skip for searching/testing of available jname
get_construct_jname()
{
	local _ok _message _input _retval _oldjname

	_oldjname="${jname}"

	f_dialog_title " jname "

	if [ "$1" = "nosearch" ]; then
			freejname=${jname}
	else
		if [ -n "${jname}" ]; then
			freejname="${jname}"
		else
			freejname=$( freejname default_jailname=${default_jailname} )
		fi
	fi
	_ok=0

	while [ ${_ok} -ne 1 ]; do
		f_dialog_input _input "${jname_msg}" "${freejname}" \
			"${_message}" || return $?

		validate_jname ${_input}
		case $? in
			1)
				jstatus jname="${_input}" >/dev/null 2>&1
				if [ $? -ne 0 ]; then
					_message="ERROR: Jail ${_input} already exist"
				else
					_ok=1
				fi
				;;
			*)
				_message="ERROR: Bad name. Choose other one"
				;;
		esac
	done

	[ -n "${_input}" ] && jname="${_input}"
	# reload some dynamic variables depended from jname
	[ -z "${jname}" ] && return 0
	if [ "${_oldjname}" != "${jname}" ]; then
		#merge_apply_profiles ${etcdir}/defaults/${zero_profile} ${global_profile_file}
		host_hostname="${jname}.${default_domain}"
		path="${jaildir}/${jname}"
		data="${jaildatadir}/${jname}-${jaildatapref}"
		mount_fstab="${jailfstabdir}/${jailfstabpref}${jname}"
		rcconf="${jailrcconfdir}/rc.conf_${jname}"
	fi
}

# form for $host_hostname
get_construct_host_hostname()
{
	local _input _defdomain

	f_dialog_title " host_hostname "

	if [ -n "${host_hostname}" ]; then
		_defdomain="${host_hostname}"
	else
		if [ -n "${default_domain}" ]; then
			if [ -z "${jname}" ]; then
				_defdomain="${jname}.${default_domain}"
			else
				_defdomain="jail1.${default_domain}"
			fi
		else
			_defdomain="my.domain"
		fi
	fi

	f_dialog_input _input "${host_hostname_msg}" "${_defdomain}" \
			"${_message}" || return $?

	[ -n "${_input}" ] && host_hostname="${_input}"
}

get_construct_ip4_addr()
{
	local _ok=0 _input _retval _i _j _existing_ipjail _existing_ip _myip
	local msg_yes msg_no IFS _jname _ips _mod=0 _tmp_input=

	. ${workdir}/vnet.subr	# is_nic_exist

	f_dialog_title " ip_addr "

	while [ ${_ok} -ne 1 ]; do
		if [ -z "${ip4_addr}" ]; then
			ip4_addr=$( dhcpd 2>/dev/null )
			if [ $? -eq 2 ]; then
				ip4_addr="DHCP"
				local msg_ok="It's a pity"
				f_dialog_msgbox "No free IP address for DHCP in nodeippool"
				return 0
			fi
		fi
		f_dialog_input _input "${ip4_addr_msg}" "${ip4_addr}" "IP4 or IP6 Address"
		_retval=$?

		[ ${_retval} -ne 0 ] && return 0

		#check ip in two phases:
		# 1) via sqlite database for other's jails ips
		# 2) for ip in LAN

		if [ -z "${_input}" -a "${_input}" = "0" -a "{_input}" = "DHCP" ]; then
			ip4_addr="${_input}"
			return 0
		fi

		# Yes, we wrote in the example that the valid separator between NIC and address
		# is '#' and not '|' as experienced jail.conf users can get used to.
		# But we will still try to convert the input with '|' to correct form
		strpos --str="${_input}" --search="|"
		_pos=$?
		 [ ${_pos} -ne 0 ] && _input=$( echo ${_input} | /usr/bin/tr '|' '#' )

		msg_yes="Ok"
		msg_no="Not Ok"

		_existing_ipjail=""
		_existing_ip=""
		_myip=""

		IFS=","
		for _i in ${_input}; do

			if [ "${_i}" = "DHCP" ]; then
				_i=$( dhcpd 2>/dev/null )
				if [ $? -eq 2 ]; then
					local msg_ok="It's a pity"
					f_dialog_msgbox "No free IP address for DHCP in nodeippool"
					return 0
				fi
				_mod=1		# modify real input by _tmp_input string ( with DHCP-obtained IP address )
			fi

			if [ -z "${_tmp_input}" ]; then
				_tmp_input="${_i}"
			else
				_tmp_input="${_tmp_input},${_i}"
			fi

			ipwmask ${_i}
			[ -z "${IWM}" -o "${_i}" = "0" ] && continue

			iptype ${IWM}
			if [ $? -ne 0 ]; then
				if [ -n "${V_INTERFACE}" -a -n "${V_IP}" ]; then
					if ! is_nic_exist -n ${V_INTERFACE}; then
						local msg_ok="I was wrong"
						f_dialog_msgbox "Interface ${V_INTERFACE} not exist!"
						return 0
					fi
					_myip="${_myip} ${V_IP}"
				else
					_myip="${_myip} ${IWM}"
				fi
			fi
		done

		[ ${_mod} -eq 1 ] && _input="${_tmp_input}"

		# check for other jail
		IFS="|"
		_i=0
		eval $( cbsdsql local SELECT jname,ip4_addr FROM jails WHERE ip4_addr!="0" 2>/dev/null |while read _jname _ips; do
			echo jname${_i}=\"$_jname\"
			echo ips${_i}=\"${_ips}\"
			_i=$(( _i + 1 ))
		done )
		unset IFS

		_ok=1

		for _i in $( /usr/bin/seq 0 255 ); do
			unset _existing_ipjail _existing_ip
			eval _jname="\$jname$_i"
			[ -z "${_jname}" ] && break
			# skip for myself
			[ "${_jname}" = "${jname}" ] && continue
			eval _existing_ipjail="\$ips$_i"
			[ -z "${_existing_ipjail}" ] && break

			_existing_ipjail=$( echo ${_existing_ipjail} | /usr/bin/tr "," " " )

			for _x in ${_existing_ipjail}; do
				[ "${_x}" = "DHCP" ] && continue
				ipwmask ${_x}
				[ -z "${IWM}" ] && continue
				iptype ${IWM}
				[ $? -eq 1 ] && _existing_ip="${_existing_ip} ${IWM}"
			done

			for _x in ${_existing_ip}; do
				for _j in ${_myip}; do
					[ "${_x}" = "${_j}" ] && _ok=0 && break
				done
				[ ${_ok} -eq 0 ] && break
			done

			if [ ${_ok} -eq 0 ]; then
				f_dialog_noyes "${_j} already assigned to jail: ${_jname}.\nIf you believe that it's ok, choose 'ok' to continue or 'not ok' for another IP address" "WARNING"
				if [ $? -eq 1 ]; then
					_ok=0
					break
				fi
				_ok=2
				break
			fi
		done # check for local jail end

		[ ${_ok} -eq 0 ] && continue # if not ok from previous stage - repeat
		[ ${_ok} -eq 2 ] && _ok=1 && continue

		_ok=1

		local _ipexist=

		# check for ip existance in LAN
		for _i in ${_myip}; do
			IFS=" "
			f_dialog_info "Probing for ${_i} availability. Please wait..."
			unset IFS
			checkip ip=${_i} check=1 2>/dev/null
			if [ $? -eq 2 ]; then
				_ok=0
				_ipexist="${_ipexist} ${_i}"
			fi
		done

		if [ ${_ok} -eq 0 ]; then
			f_dialog_noyes "Seems like ${_ipexist} address already used on several devices on the LAN\nYou can found MAC address by \"arp -an\" command.\n If you believe that it's ok, choose 'ok' to continue or 'not ok' for another IP address" "WARNING"
			[ $? -eq 0 ] && _ok=1
		fi
	done

	ip4_addr="${_input}"
	return 0
}

# form for $interface
# -b 1 - add "bridge" device
# -c choose_default item - defaultitem set to this value
# -s "skip this network list"
# -d 1  - add "disable" choice
# -m 1  - add "manual" choice
# -v 1  - add "vale" device
get_construct_interface()
{
	local _input _def_iface _mynic _mydesc _mystatus
	local defaultitem _skipnics="" _disable=0 _choose
	local _manual=0 _vale=0 _bridge=0

	local title=" interface "
	local prompt="${interface_msg}"
	hline=

	local menu_list="
		'EXIT'	'EXIT'	'Exit'
	" # END-QUOTE

	while getopts "b:c:s:d:m:v:" opt; do
		case "$opt" in
			b) _bridge="${OPTARG}" ;;
			c) _choose="${OPTARG}" ;;
			s) _skipnics="${OPTARG}" ;;
			d) _disable="${OPTARG}" ;;
			m) _manual="${OPTARG}" ;;
			o) _optional="${OPTARG}" ;;
			v) _vale="${OPTARG}" ;;
		esac
		shift $(($OPTIND - 1))
	done

	menu_list="${menu_list} 'auto'		'auto'		'Recommended: determine nic for jail IP via route table.'"
	if [ "${_manual}" = "1" ]; then
		menu_list="${menu_list} 'manual'	'manual'	'Enter interface by hand.'"
	fi

	if [ ${_disable} -eq 1 ]; then
		menu_list="${menu_list} 'disable'	'disable'	'Do not create/remove IP automatically: IP of jail must be already initialized or for vnet mode'"
	fi
	menu_list="${menu_list} '-'	'-'	''"

	local OLDIFS="${IFS}"
	local IFS=":"

	local _num=1

	eval $( ${miscdir}/nics-list -da -s "${_skipnics}" |while read _nicname _nicdesc _nicstatus; do
		echo "nic${_num}_name=\"${_nicname}\""
		echo "nic${_num}_desc=\"${_nicdesc}\""
		echo "nic${_num}_status=\"${_nicstatus}\""
		_num=$(( _num + 1 ))
		echo "_num=\"${_num}\""
	done )

	if [ "${_vale}" = "1" ]; then
		eval $( cbsdsql local SELECT name FROM vale | while read name; do
			echo "nic${_num}_name=\"vale_${name}\""
			echo "nic${_num}_desc=\"VALE SWITCH: ${name}\""
			echo "nic${_num}_status=\"UP\""
			_num=$(( _num + 1 ))
			echo "_num=\"${_num}\""
		done )
#		eval "nic${_num}_name='vale'"
#		eval "nic${_num}_desc='very fast Virtual Local Ethernet using the netmap API'"
#		eval "nic${_num}_status='UP'"
	fi

	if [ "${_bridge}" = "1" ]; then
		#menu_list="${menu_list} '-'	'Existing bridges'	'Use existing bridges'"
		eval $( ${miscdir}/nics-list -o "bridge" | while read _nicname; do
			echo "nic${_num}_name=\"${_nicname}\""
			echo "nic${_num}_status=\"initialized\""
			_num=$(( _num + 1 ))
			echo "_num=\"${_num}\""
		done )
	fi

	IFS="${OLDIFS}"

	if [ -n "${interface}" ]; then
		case "${interface}" in
			"0")
				defaultitem="disable"
				;;
			*)
				defaultitem="${interface}"
				;;
		esac
	else
		if [ -n "${_choose}" ]; then
			defaultitem="${_choose}"
		elif [ -n "${interface}" ]; then
			defaultitem="${interface}"
		else
			interface="auto"
			defaultitem="auto"
		fi
	fi

	[ -n "${_choose}" ] && defaultitem="${_choose}"

	for _num in $( /usr/bin/seq 1 9999 ); do
		unset _mynic _mydesc _mystatus
		eval _mynic="\$nic${_num}_name"
		[ -z "${_mynic}" ] && break
		eval _mydesc="\$nic${_num}_desc"
		eval _mystatus="\$nic${_num}_status"
		case "${_mynic%%[0-9]*}" in
			tun|bridge|epair|tap|vlan)
				_mydesc="Pseudo interface"
				;;
			lo)
				_mydesc="Loopback interface"
				;;
		esac
		[ -z "${_mydesc}" ] && _mydesc="Not available"
		menu_list="${menu_list} '${_mynic}'	'${_mynic} (${_mystatus} )'	'Description: ${_mydesc}'"
	done

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			case "${mtag}" in
				"-")
					continue
					;;
				EXIT)
					return 1
					;;
				disable)
					interface="0"
					;;
				manual)
					defaultitem="auto"
					title=" interface "
					prompt="Enter interface"
					cbsd_inputbox_simple && interface="${mtag}"
					;;
				*)
					[ -n "${mtag}" ] && interface="${mtag}"
					;;
			esac
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $ver
get_construct_ver()
{
	title=" ver "
	prompt="${ver_msg}"
	defaultitem="${ver}"

	cbsd_inputbox_simple && ver="${mtag}"
}

# form for $bhyve_flags
get_construct_bhyve_flags()
{
	title=" additioal bhyve_flags "
	prompt="enter additional bhyve(8) args"
	defaultitem="${bhyve_flags}"

	cbsd_inputbox_simple && bhyve_flags="${mtag}"
}

# form for $basename
get_construct_basename()
{
	title=" basename "
	prompt="${basename_msg}"
	defaultitem="${basename}"

	cbsd_inputbox_simple && basename="${mtag}"
}

# form for $exec_stop
get_construct_exec_stop()
{
	title=" exec_stop "
	prompt=" Redefine for exec_stop "
	defaultitem="${exec_stop}"

	cbsd_inputbox_simple && exec_stop="${mtag}"
}

# form for $exec_start
get_construct_exec_start()
{
	title=" exec_start "
	prompt=" Redefine for exec_start "
	defaultitem="${exec_start}"

	cbsd_inputbox_simple && exec_start="${mtag}"
}

# form for $childrenmax
get_construct_childrenmax()
{
	title=" childrenmax "
	prompt="${childrenmax_msg}"
	defaultitem="${childrenmax}"

	cbsd_inputbox_simple && childrenmax="${mtag}"
}

# form for $enforce_statfs
get_construct_enforce_statfs()
{
	title=" enforce_statfs "
	prompt="${enforce_statfs_msg}"
	defaultitem="${enforce_statfs}"

	cbsd_inputbox_simple && enforce_statfs="${mtag}"
}


# form for $zfs_snapsrc
get_construct_zfs_snapsrc()
{
	title=" zfs_snapsrc "
	prompt="${zfs_snapsrc_msg}"
	defaultitem="${zfs_snapsrc}"

	if cbsd_inputbox_simple; then
		if [ -n "${mtag}" ]; then
			zfs_snapsrc="${mtag}"
		else
			unset zfs_snapsrc
		fi
	fi
}


# form for select password
# if $1 - can_empty than allow empty passowrd
get_password()
{
	local prompt1="Enter New Password"
	local prompt2="Re-enter Password"
	local hline="Use alpha-numeric, punctuation, TAB or ENTER"

	if [ "${1}" = "can_empty" ]; then
		local can_empty=1
	else
		local can_empty=0
	fi

	f_dialog_title " Select Password "

	local height1 width1
	f_dialog_inputbox_size height1 width1 \
		"$DIALOG_TITLE"     \
		"$DIALOG_BACKTITLE" \
		"$prompt1"          \
		""                  \
		"$hline"

	local height2 width2
	f_dialog_inputbox_size height2 width2 \
		"$DIALOG_TITLE"     \
		"$DIALOG_BACKTITLE" \
		"$prompt2"          \
		""                  \
		"$hline"

	#
	# Loop until the user provides taint-free/valid input
	#
	local _password1 _password2
	while :; do
		_password1=$( $DIALOG \
			--title "$DIALOG_TITLE"         \
			--backtitle "$DIALOG_BACKTITLE" \
			--hline "$hline"                \
			--ok-label "$msg_ok"            \
			--cancel-label "$msg_cancel"    \
			--insecure                      \
			--passwordbox "$prompt1"        \
			$height1 $width1                \
			2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
		) || return $?
		# Return if user either pressed ESC or chose Cancel/No
		debug= f_dialog_line_sanitize _password1

		_password2=$( $DIALOG \
				--title "$DIALOG_TITLE"         \
				--backtitle "$DIALOG_BACKTITLE" \
				--hline "$hline"                \
				--ok-label "$msg_ok"            \
				--cancel-label "$msg_cancel"    \
				--insecure                      \
				--passwordbox "$prompt2"        \
				$height2 $width2                \
				2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
			) || return $?
		# Return if user either pressed ESC or chose Cancel/No
		debug= f_dialog_line_sanitize _password2

		if [ ${can_empty} -eq 0 ]; then
			# Check for NULL entry
			if ! [ "$_password1" -o "$_password2" ]; then
				f_show_msg "Password is empty"
				continue
			fi
			mtag=''
		fi

		# Check for password mismatch
		if [ "$_password1" != "$_password2" ]; then
			f_show_msg "Password do not match"
			continue
		fi

		mtag="$_password1"
		break
	done

	return $DIALOG_OK
}


# form for $user_pw_root
get_construct_user_pw_root()
{
	if get_password; then
		user_pw_root_crypt=$( ${miscdir}/pwcrypt ${mtag} )
		if [ $? -eq 0 ]; then
			unset user_pw_root
		else
			user_pw_root="${mtag}"
			unset user_pw_root_crypt
		fi
	fi
}

# form for $vnc_password
get_construct_vnc_password()
{
	if get_password can_empty; then
		vnc_password="${mtag}"
	else
		unset vnc_password
	fi

	[ -z "${vnc_password}" ] && vnc_password="0"
}

# form for $bhyve_vnc_vgaconf
get_construct_bhyve_vnc_vgaconf_menu()
{
	local _input _res

	# for default values
	readconf vnc.conf

	local title="VGACONF setting"
	local defaultitem="${bhyve_vnc_vgaconf}"

	local menu_list="
		'io'	'io'	'I/O port queries'
		'on'	'on'	'for legacy VGA I/O and memory regions'
		'off'	'off'	'VGA adapter is present if they detect the I/O ports'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && bhyve_vnc_vgaconf="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}

}

# form for $debug_engine
get_construct_debug_engine()
{
	local _input _res

	local title="Debug engine"
	local defaultitem="${debug_engine}"

	local menu_list="
		'gdb'	'gdb'	'GNU debugger'
		'lldb'	'lldb'	'LLVM debuger'
		'none'	'none'	'No debuger'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && debug_engine="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}

}


# form for $path
get_construct_path()
{
	title=" path "
	prompt="${path_msg}"
	defaultitem="${path}"

	cbsd_inputbox_simple && path="${mtag}"
}

# form for $data
get_construct_data()
{
	title=" data "
	prompt="${data_msg}"
	defaultitem="${data}"

	cbsd_inputbox_simple && data="${mtag}"
}


# form for $devfs_ruleset
get_construct_devfs_ruleset()
{
	title=" devfs_ruleset "
	prompt="${devfs_ruleset_msg}"
	defaultitem="${devfs_ruleset}"

	cbsd_inputbox_simple && devfs_ruleset="${mtag}"
}

# $1 - 1,0 - default values
get_construct_yesno()
{
	local _default=1
	msg_yes="no"
	msg_no="yes"

	[ -n "${1}" ] && _default="${1}"

	if [ ${_default} -eq 0 ]; then
		f_dialog_yesno "${msg}" "${hline}"
	else
		f_dialog_noyes "${msg}" "${hline}"
	fi

	return $?
}

get_construct_mdsize()
{
	title=" mdsize "
	prompt="${mdsize_msg}"
	defaultitem="${mdsize}"

	cbsd_inputbox_simple && mdsize="${mtag}"
}

get_construct_imgsize()
{
	local _input

	f_dialog_title " imgsize "

	f_dialog_input _input "${GET_IMGSIZE_MSG}:" "${imgsize}" \
			"${_message}" || return $?

	imgsize="${_input}"
}

get_construct_swapsize()
{
	local _input

	f_dialog_title " swapsize "

	f_dialog_input _input "${GET_SWAPSIZE_MSG}:" "${swapsize}" \
			"${_message}" || return $?

	swapsize="${_input}"
}


# form for $exec_timeout
get_construct_exec_timeout()
{
	local _input

	f_dialog_title " exec_timeout "

	f_dialog_input _input "${exec_timeout_msg}" "${exec_timeout}" \
			"${_message}" || return $?

	exec_timeout="${_input}"
}

# form for $exec_fib
get_construct_exec_fib()
{
	local _input

	f_dialog_title " exec_fib "

	f_dialog_input _input "${exec_fib_msg}" "${exec_fib}" \
			"${_message}" || return $?

	exec_fib="${_input}"
}

# form for $exec_consolelog
get_construct_exec_consolelog()
{
	local _input

	f_dialog_title " exec_consolelog "

	f_dialog_input _input "${exec_consolelog_msg}" "${exec_consolelog}" \
		"${_message}" || return $?

	exec_consolelog="${_input}"
}

# form for $stop_timeout
get_construct_stop_timeout()
{
	local _input

	f_dialog_title " stop_timeout "

	f_dialog_input _input "${stop_timeout_msg}" "${stop_timeout}" \
		"${_message}" || return $?

	stop_timeout="${_input}"
}

# form for $depend
get_jail_depend()
{
	local _input

	f_dialog_title " depend "

	f_dialog_input _input "${depend_msg}" \
		"${_message}" || return $?

	depend="${_input}"
}

# form for $cpuset
get_construct_cpuset()
{
	local _input

	f_dialog_title " cpuset "

	f_dialog_input _input "${cpuset_msg}" "${cpuset}" \
			"${_message}" || return $?

	cpuset="${_input}"
}

# form for $cpus
get_construct_vm_cpus()
{
	local _input _message=" current hoster logical CPUs: ${ncpu} "
	local _ret=1

	f_dialog_title " vCpus "

	while [ ${_ret} -ne 0 ]; do

		f_dialog_input _input "${GET_CPUS_MSG}" "${vm_cpus}" \
			"${_message}" || return $?

		if is_number ${_input}; then
			f_show_msg "Only number is valid input for cpu"
			continue
		fi

		if [ ${_input} -gt ${ncpu} -a ${_input} -lt 16 ]; then
			if ! getyesno "Warning! Current node cpu: ${ncpu}. Overcommitting vCPUs can hurt perfomance.\nContinue anyway?"; then
				continue
			fi
		elif [ ${_input} -lt 1 -o ${_input} -gt 16 ]; then
			f_show_msg "Valid number of guest CPUs within 1 - 16 range"
			continue
		fi
		_ret=0
	done
	vm_cpus="${_input}"
}


# form for $vm_vnc_port
get_construct_vm_vnc_port()
{
	local _input

	f_dialog_title " vnc port "

	f_dialog_input _input "${GET_VM_VNC_PORT_MSG}" "${vm_vnc_port}" \
			"${_message}" || return $?

	vm_vnc_port="${_input}"
}

# form for $ram
get_construct_vm_ram()
{
	local _input _tmp

	f_dialog_title " ram "

	f_dialog_input _input "${GET_RAM_MSG}" "${vm_ram}" \
			"${_message}" || return $?

	# test for human
	if ! is_number "${_input}"; then
		# is number. assume user's input value in MB, so convert to bytes
		_input=$(( _input * 1024 * 1024 ))
		if conv2human "${_input}"; then
			_tmp="${convval}"
		else
			_tmp=$(( _input * 1024 * 1024 ))
			if conv2human "${VAL}"; then
				_tmp="${convval}"
			fi
		fi
	else
		_tmp="${_input}"
	fi

	vm_ram="${_tmp}"
}

# form for $vm_iso_path
get_construct_isopath()
{
	local _input

	f_dialog_title " isopath "

	f_dialog_input _input "${GET_ISOPATH_MSG}" "${vm_iso_path}" \
			"${_message}" || return $?

	vm_iso_path="${_input}"
}

# form for $arch
get_construct_arch()
{
	local _input _res

	local qemu_mips64=$( /usr/bin/which qemu-mips64-static 2>/dev/null )
	local qemu_arm=$( /usr/bin/which qemu-arm-static 2>/dev/null )
	local qemu_aarch64=$( /usr/bin/which qemu-aarch64-static 2>/dev/null )

	local amd64_menu=
	local i386_menu=
	local amd64_desc=
	local i386_desc=

	local arm_menu=
	local mips_menu=
	local arm_desc=
	local mips_desc=

	local qemu_mips64_desc=
	local qemu_arm_desc=
	local qemu_aarch64_desc=

	local qemu_mips64_enable=
	local qemu_arm_enable=
	local qemu_aarch64_enable=

	local qemu_mips64_menu="MIPS64"
	local qemu_arm_menu="ARMv6"
	local qemu_aarch64_menu="ARMv8"

	# test for qemu_mips64
	if [ -n "${qemu_mips64}" ]; then
		_res=$( 2>&1 /usr/bin/ldd ${qemu_mips64} |${GREP_CMD} -q "not a dynamic ELF executable" )
		if [ $? -eq 0 ]; then
			qemu_mips64_enable=1
			qemu_mips64_desc="MIPS64 via ${qemu_mips64}"
		else
			qemu_mips64_enable=0
			qemu_mips64_desc="${qemu_mips64} is not static. Please rebuild with STATIC ( emulators/qemu-user-static )"
		fi
	else
		qemu_mips64_enable=0
		qemu_mips64_desc="You have no qemu-user: please install qemu-devel with BSD_USER and STATIC ops ( emulators/qemu-user-static )"
	fi

	# test for qemu_arm
	if [ -n "${qemu_arm}" ]; then
		_res=$( 2>&1 /usr/bin/ldd ${qemu_arm} |${GREP_CMD} -q "not a dynamic ELF executable" )
		if [ $? -eq 0 ]; then
			qemu_arm_enable=1
			qemu_arm_desc="ARM via ${qemu_arm}"
		else
			qemu_arm_enable=0
			qemu_arm_desc="${qemu_arm} is not static. Please rebuild with STATIC ( emulators/qemu-user-static )"
		fi
	else
		qemu_arm_enable=0
		qemu_arm_desc="You have no qemu-user: please install qemu-devel with BSD_USER and STATIC ops ( emulators/qemu-user-static )"
	fi

	# test for qemu_aarch64
	if [ -n "${qemu_aarch64}" ]; then
		_res=$( 2>&1 /usr/bin/ldd ${qemu_aarch64} |${GREP_CMD} -q "not a dynamic ELF executable" )
		if [ $? -eq 0 ]; then
			qemu_aarch64_enable=1
			qemu_aarch64_desc="aarch64 aka ARMv8 and arm-64 via ${qemu_arm}"
		else
			qemu_aarch64_enable=0
			qemu_aarch64_desc="${qemu_aarch64} is not static. Please rebuild with STATIC ( emulators/qemu-user-static )"
		fi
	else
		qemu_aarch64_enable=0
		qemu_aarch64_desc="You have no qemu-user: please install qemu-devel with BSD_USER and STATIC ops ( emulators/qemu-user-static )"
	fi

	local defaultitem="${arch}"

	case "${hostarch}" in
		"amd64")
			amd64_menu="*"
			amd64_desc="This is native architecture for this node"
			;;
		"i386")
			i386_menu="*"
			i386_desc="This is native architecture for this node"
			;;
		"arm")
			arm_menu="*"
			arm_desc="This is native architecture for this node"
			;;
		"aarch64")
			aarch64_menu="*"
			aarch64_desc="This is native architecture for this node"
			;;
		"mips")
			mips_menu="*"
			mips_desc="This is native architecture for this node"
			;;
	esac

	case "${arch}" in
		amd64)
			local menu_list="
			'amd64'	'x86-64 ${amd64_menu}'		'64 bit architecture. ${amd64_desc}'
			'i386'	'x86 ${i386_menu}'		'32 bit architecture. ${i386_desc}'
			" # END-QUOTE
			;;
		i386)
			local menu_list="
			'i386'	'x86 ${i386_menu}'		'32 bit architecture. ${i386_desc}'
			" # END-QUOTE
			;;
		arm)
			local menu_list="
			'arm'	'arm ${arm_menu}'		'ARM architecture. ${arm_desc}'
			" # END-QUOTE
			;;
		aarch64)
			local menu_list="
			'arm'	'aarch64 ${aarch64_menu}'	'ARM architecture. ${aarch64_desc}'
			" # END-QUOTE
			;;
		mips)
			local menu_list="
			'mips'	'mips ${mips_menu}'		'MIPS architecture. ${mips_desc}'
			" # END-QUOTE
			;;
		*)
			local menu_list="
			'amd64'	'x86-64 ${amd64_menu}'		'64 bit architecture. ${amd64_desc}'
			'i386'	'x86 ${i386_menu}'		'32 bit architecture. ${i386_desc}'
			" # END-QUOTE
			;;
	esac

	if [ ${qemu_arm_enable} -eq 1 ]; then
		menu_list="${menu_list} 'arm'	'${qemu_arm_menu}'	'${qemu_arm_desc}'"
	else
		menu_list="${menu_list} ''	'armv6 unsupported'	'${qemu_arm_desc}'"
	fi

	if [ ${qemu_aarch64_enable} -eq 1 ]; then
		menu_list="${menu_list} 'aarch64'	'${qemu_aarch64_menu}'	'${qemu_aarch64_desc}'"
	else
		menu_list="${menu_list} ''		'aarch64 unsupported'	'${qemu_aarch64_desc}'"
	fi

	if [ ${qemu_mips64_enable} -eq 1 ]; then
		menu_list="${menu_list} 'mips'	'${qemu_mips64_menu}'	'${qemu_mips64_desc}'"
	else
		menu_list="${menu_list} ''	'mips unsupported'	'${qemu_mips64_desc}'"
	fi

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			if [ -n "${mtag}" ]; then
				arch="${mtag}"
			else
				arch="${hostarch}"
			fi
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_hostbridge
get_construct_vm_hostbridge()
{
	local _input _res

	local title="${GET_HOSTBRIDGE_MSG}"
	local defaultitem="${vm_hostbridge}"

	local menu_list="
		'hostbridge'		'hostbridge'		'Provide a simple host bridge.'
		'amd_hostbridge'	'amd_hostbridge'	'The amd_hostbridge emulation is identical but uses a PCI vendor ID of AMD'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_hostbridge="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vnc_resolution
get_construct_bhyve_vnc_resulution_menu()
{
	local _input _res

	# for default values
	readconf vnc.conf

	local title="VNC Resolution"
	local defaultitem="${bhyve_vnc_resolution}"

	local menu_list="
		'640x480'		'640 x 480'		'640 x 480'
		'800x600'		'800 x 600'		'800 x 600'
		'1024x768'		'1024 x 768'		'1024 x 768'
		'1280x720'		'1280 x 720'		'1280 x 720'
		'1280x1024'		'1280 x 1024'		'1280 x 1024'
		'1600x900'		'1600 x 900'		'1600 x 900'
		'1600x1200'		'1600 x 1200'		'1600 x 1200'
		'1920x1080'		'1920 x 1080'		'1920 x 1080'
		'1920x1200'		'1920 x 1200'		'1920 x 1200'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && bhyve_vnc_resolution="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $allow_sysvipc
get_construct_allow_sysvipc()
{
	local _input _res

	local title="${GET_ALLOW_SYSVIPC_MSG}"
	local defaultitem="${allow_sysvipc}"

	local menu_list="
		'new'			'new'			'New SYSV IPC: separated isolated segments for jail (FreeBSD 11+)'
		'inherit'		'inherit'		'Inherit (shared) SYSV IPC from parent environment'
		'disable'		'disable'		'Disable SYSV IPC within jail'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && allow_sysvipc="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# Submenu for bhyve options
get_construct_bhyve_options_menu()
{
	local _input _res item_let=A

	local title="Additional bhyve arguments"
	local defaultitem=
	local menu_choice=
	local _checkbox="bhyve_generate_acpi bhyve_wire_memory bhyve_rts_keeps_utc bhyve_force_msi_irq bhyve_x2apic_mode bhyve_mptable_gen bhyve_ignore_msr_acc"

	f_dialog_default_fetch defaultitem

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} bhyve_generate_acpi'		'[${bhyve_generate_acpi_mark}]'		'Generate ACPI tables.  Required for FreeBSD/amd64 guests'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_wire_memory'			'[${bhyve_wire_memory_mark}]'		'Wire guest memory'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_rts_keeps_utc'		'[${bhyve_rts_keeps_utc_mark}]'		'RTC keeps UTC time'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_force_msi_irq'		'[${bhyve_force_msi_irq_mark}]'		'Force virtio PCI device to use MSI interrupts instead of MSI-X'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_x2apic_mode'			'[${bhyve_x2apic_mode_mark}]'		'The guests local APIC is configured in x2APIC mode'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_mptable_gen'			'[${bhyve_mptable_gen_mark}]'		'Disable MPtable generation'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_ignore_msr_acc'		'[${bhyve_ignore_msr_acc_mark}]'	'Ignore accesses to unimplemented MSRs'"

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}


# Submenu for vnc options
get_construct_bhyve_vnc_options_menu()
{
	local _input _res item_let=A

	local title="VNC Options"
	local defaultitem=
	local menu_choice=
	local _checkbox="cd_vnc_wait"

	f_dialog_default_fetch defaultitem

	readconf vnc.conf
	[ -z "${bhyve_vnc_resolution}" ] && bhyve_vnc_resolution="${default_vnc_width}x${default_vnc_height}"
	[ -z "${bhyve_vnc_tcp_bind}" ] && bhyve_vnc_tcp_bind="${default_vnc_tcp_bind}"
	[ -z "${bhyve_vnc_vgaconf}" ] && bhyve_vnc_vgaconf="${default_vnc_vgaconf}"

	if [ "${vnc_password}" = "0" ]; then
		unset vnc_password
	else
		[ -z "${vnc_password}" ] && vnc_password="${default_vnc_password}"
	fi

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} cd_vnc_wait'		'[${cd_vnc_wait_mark}]'		'When booting from CD - wait connections on VNC before VM run'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_vnc_resolution'	'[${bhyve_vnc_resolution}]'	'Default: width - ${default_vnc_width}, height - ${default_vnc_height}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_vnc_tcp_bind'	'[${bhyve_vnc_tcp_bind}]'	'Default: ${default_vnc_tcp_bind}'"

	# vgaconf support introduced in FreeBSD 11.1+

	if [ ${freebsdhostversion} -gt 1101000 ]; then
		inc_menu_index item_let
		menu_list="${menu_list} '${item_let} bhyve_vnc_vgaconf'		'[${bhyve_vnc_vgaconf}]'	'Default: ${default_vnc_vgaconf}'"
	fi

	# VNC password support introduced in FreeBSD 11.1
	if [ ${freebsdhostversion} -gt 1101000 ]; then
		inc_menu_index item_let
		menu_list="${menu_list} '${item_let} vnc_password'		'[${vnc_password}]'		'Default: see vnc.conf file'"
	fi

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}


# Submenu for vnc options
get_construct_xen_vnc_options_menu()
{
	local _input _res item_let=A

	local title="VNC Options"
	local defaultitem=
	local menu_choice=
	local _checkbox="cd_vnc_wait"

	f_dialog_default_fetch defaultitem

	readconf vnc.conf
	[ -z "${xen_vnc_resolution}" ] && xen_vnc_resolution="${default_vnc_width}x${default_vnc_height}"
	[ -z "${xen_vnc_tcp_bind}" ] && xen_vnc_tcp_bind="${default_vnc_tcp_bind}"
	[ -z "${xen_vnc_vgaconf}" ] && xen_vnc_vgaconf="${default_vnc_vgaconf}"

	if [ "${vnc_password}" = "0" ]; then
		unset vnc_password
	else
		[ -z "${vnc_password}" ] && vnc_password="${default_vnc_password}"
	fi

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

#	menu_list="${menu_list} '${item_let} cd_vnc_wait'		'[${cd_vnc_wait_mark}]'		'When booting from CD - wait connections on VNC before VM run'"
#	inc_menu_index item_let
#	menu_list="${menu_list} '${item_let} xen_vnc_resolution'	'[${xen_vnc_resolution}]'	'Default: width - ${default_vnc_width}, height - ${default_vnc_height}'"
#	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} xen_vnc_tcp_bind'		'[${xen_vnc_tcp_bind}]'	'Default: ${default_vnc_tcp_bind}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} vnc_password'		'[${vnc_password}]'		'Default: see vnc.conf file'"

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}



# Submenu for bhyve options
get_construct_bhyve_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_bhyve_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"

}


# Submenu for bhyve options
get_construct_bhyve_vnc_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_bhyve_vnc_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		bhyve_vnc_tcp_bind)
			title=" vnc bind "
			prompt="default via vnc.conf: ${default_vnc_tcp_bind}\nUse 0.0.0.0 for all IPs"
			defaultitem="${bhyve_vnc_tcp_bind}"
			cbsd_inputbox_simple && bhyve_vnc_tcp_bind="${mtag}"
			;;
		bhyve_vnc_resolution)
			get_construct_bhyve_vnc_resulution_menu
			;;
		bhyve_vnc_vgaconf)
			get_construct_bhyve_vnc_vgaconf_menu
			;;
		vnc_password)
			get_construct_vnc_password
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"

}


# Submenu for xen vnc options
get_construct_xen_vnc_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_xen_vnc_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		xen_vnc_tcp_bind)
			title=" vnc bind "
			prompt="default via vnc.conf: ${default_vnc_tcp_bind}\nUse 0.0.0.0 for all IPs"
			defaultitem="${xen_vnc_tcp_bind}"
			cbsd_inputbox_simple && xen_vnc_tcp_bind="${mtag}"
			;;
		xen_vnc_resolution)
			get_construct_xen_vnc_resulution_menu
			;;
		xen_vnc_vgaconf)
			get_construct_xen_vnc_vgaconf_menu
			;;
		vnc_password)
			get_construct_vnc_password
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"
}


# form for $vm_guestfs
get_construct_vm_guestfs()
{
	local _input _res

	local title="${GET_GUESTFS_MSG}"
	local defaultitem="${vm_guestfs}"

	local menu_list="
		'zfs'	'zfs'	'ZFS filesystem'
		'ufs'	'ufs'	'UFS filesystem'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_guestfs="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_boot
get_construct_vm_boot()
{
	local _res

	local vm_boot_data="${ftmpdir}/vm_boot.$$"

	bootmgmt selected=${vm_boot} controlmaster=${vm_boot_data}

	retval=$?

	case $retval in
		${DIALOG_OK})
			. ${vm_boot_data}
			;;
		*)
			;;
	esac

	/bin/rm -f ${vm_boot_data}

	return ${retval}
}

# form for $vm_efi
get_construct_vm_efi()
{
	local _input _res

	local title="${GET_EFI_MSG}"
	local defaultitem="${vm_efi}"

	local menu_list="
		'none'		'No UEFI boot'	'Legacy boot mode'
		'uefi'		'UEFI'		'Boot using UEFI firmware'
		'uefi_csm'	'UEFI CSM'	'Boot using UEFI CSM firmware'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_efi="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# update vm_\* values according to $vm_package data
# if $1 - "force", all variables will be overwrited
#  otherwise, assign variables only vm_\* is empty
# $vm_package variables must be set
apply_vm_package()
{
	[ -z "${vm_package}" ] && return 0
	[ "${1}" = "force" ] && unset vm_cpus vm_ram imgsize

	[ -z "${vm_cpus}" ] && vm_cpus=$( cbsdsql local SELECT pkg_vm_cpus FROM vmpackages WHERE name=\"${vm_package}\" )
	[ -z "${vm_ram}" ] && vm_ram=$( cbsdsql local SELECT pkg_vm_ram FROM vmpackages WHERE name=\"${vm_package}\" )
	[ -z "${imgsize}" ] && imgsize=$( cbsdsql local SELECT pkg_vm_disk FROM vmpackages WHERE name=\"${vm_package}\" )

	return 0
}

# form for $vm_package
get_construct_vm_package()
{
	local _input _res

	local title="${GET_VM_PACKAGE_MSG}"
	local defaultitem="${vm_package}"

	local sqldelimer=" "

	local menu_list=$( cbsdsql local SELECT name,pkg_vm_cpus,pkg_vm_ram,pkg_vm_disk FROM vmpackages | while read name pkg_vm_cpus pkg_vm_ram pkg_vm_disk; do
		echo "'${name}' '[${mark}] name=${name} CPU=${pkg_vm_cpus} RAM=${pkg_vm_ram} DISK=${pkg_vm_disk}'  'description'"
	done ) || err 1 "${MAGENTA}Error while create packages map${NORMAL}"

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_package="${mtag}"
			apply_vm_package force
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_console
get_construct_vm_console()
{
	local _input _res

	local title="${GET_CONSOLE_MSG}"
	local defaultitem="${vm_console}"

	local menu_list="
		'tmux'		'tmux console'			'No serial, just tmux session'
		'nmdm'		'serial console via nmdm'	'Serial console via nullmodem driver'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_console="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $imgtype
get_construct_imgtype()
{
	local _input _res

	local title="${GET_IMGTYPE_MSG}"
	local defaultitem="${imgtype}"

	local menu_list="
		'zvol'		'ZFS volume'			'Use ZVOL. This is a faster bakend than md'
		'md'		'use mdconfig(8) as backend'	'Use MD if your want to have guest FS-in-file on the hoster FS'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && imgtype="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_os_type
# if $1 = "value" apply value without dialog
get_construct_vm_os_type()
{
	local _input
	local defaultitem="${vm_os_type}"

	if [ -n "${1}" ]; then
		vm_os_type="${1}"
		retval=${DIALOG_OK}
	else
		unset menu_list

		# load menu_list from external source by emulator opportunity
		if [ -f "${sharedir}/emulators/ostype_${emulator}.subr" ]; then
			. ${sharedir}/emulators/ostype_${emulator}.subr
		else
			f_dialog_msgbox "No such menu_list for emulator ${emulator}:\n${sharedir}/emulators/ostype_${emulator}.subr"
			return 0
		fi

		cbsd_menubox
		retval=$?
	fi

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_os_type="${mtag}"
			unset vm_os_profile jname imgsize vm_ram vm_cpus
			apply_vm_package
			;;
		*)
			;;
	esac

	return ${retval}
}


get_construct_vm_iso_path()
{
	local menu_list=
	local vm_res
	local i

	local title=" Select ISO "
	local prompt="${GET_VM_ISOPATH_MSG}"
	local iso_path

	vm_res=$( cbsdsql storage_media SELECT name FROM media WHERE type=\"iso\" )

	[ -z "${vm_res}" ] && return 0

	for i in ${vm_res}; do
		menu_list="${menu_list} '${i}' '${i}' '${i}'"
	done

	menu_list="${menu_list} 'Detach' 'Detach' 'Detach any CD ISO'"

	defaultitem="${vm_iso_path}"

	mtag=
	cbsd_menubox

	case $retval in
		${DIALOG_OK})
			if [ -n "${mtag}" ]; then
				case "${mtag}" in
					Detach)
						cbsdsql storage_media "UPDATE media SET jname='-' WHERE jname=\"${jname}\" AND type=\"iso\""
						register_iso_as=
						vm_iso_path=
						alt_iso=
						;;
					*)
						register_iso_as="${mtag}"
						vm_iso_path="${mtag}"
						alt_iso="${mtag}"
						iso_path=$( cbsdsql storage_media SELECT path FROM media WHERE type=\"iso\" AND name=\"${mtag}\" )
						# remove old disk if exist
						cbsdsql storage_media "UPDATE media SET jname='-' WHERE jname=\"${jname}\" AND type=\"iso\""
						echo "media mode=attach type=iso name=${mtag} path=${iso_path} jname=${jname}"
						media mode=attach type=iso name=${mtag} path=${iso_path} jname=${jname}
						;;
				esac
			fi
			;;
		*)
			;;
	esac

	return ${retval}
}

get_construct_vm_cpu_topology()
{
	local menu_list=
	local vm_res
	local i
	local _query _sockets _cores _threads _vm_cores

	local title=" Select CPU topology "
	local prompt="${GET_VM_CPU_TOPOLOGY_MSG}"
	local iso_path

	vm_res=$( cbsdsql local SELECT name FROM vm_cpu_topology | /usr/bin/xargs )

	[ -z "${vm_res}" ] && return 0
	. ${strings}
	. ${workdir}/virtual.subr

	for i in ${vm_res}; do
		_query=$( cbsdsql local SELECT sockets,cores,threads FROM vm_cpu_topology WHERE name=\"${i}\" )
		[ -z "${_query}" ] && return 0
		OIFS="${IFS}"
		IFS="|"
		sqllist "${_query}" _sockets _cores _threads
		IFS="${OIFS}"
		_vm_cores=$( get_vm_cores_by_topology ${_sockets} ${_cores} ${_threads} )
		local topology_${i}_cpus="${_vm_cores}"
		menu_list="${menu_list} '${i}' 'sockets=${_sockets},cores=${_cores},threads=${_threads}' 'sockets=${_sockets},cores=${_cores},threads=${_threads}, Core: ${_vm_cores}'"
	done

	menu_list="${menu_list}"
	defaultitem="${vm_cpu_topology}"

	mtag=
	cbsd_menubox

	case ${retval} in
		${DIALOG_OK})
			if [ -n "${mtag}" ]; then
				vm_cpu_topology="${mtag}"
				eval vm_cpus="\$topology_${mtag}_cpus"
			fi
			;;
		*)
			;;
	esac

	return ${retval}
}

# try to update profiles from GitHub via Internet
get_profiles_update()
{
	local _git
	local _logfile

	_git=$( which git )

	if [ -z "${_git}" ]; then
		local msg_ok="It's a pity"
		f_dialog_msgbox "No git in system. Please install git first: pkg install -y devel/git"
		return 0
	fi

	_logfile=$( /usr/bin/mktemp )

	trap "/bin/rm -f ${_logfile}" HUP INT ABRT BUS TERM EXIT

	f_dialog_info "Updating from GitHub repository. Please wait..."
	f_dialog_title " Log messages "
	echo >> ${_logfile}
	/usr/bin/make -C ~cbsd/etc profiles-upgrade >> ${_logfile} 2>&1
	f_show_help "${_logfile}"
	/bin/rm -f ${_logfile}
	trap "" HUP INT ABRT BUS TERM EXIT
}


# form for $vm_os_profile
# if $1 not empty just load profile without dialogizing
get_construct_vm_os_profile()
{
	local _input _search_profile="vm-${vm_os_type}" _res vm_profile _myprofiles="" _myfile _all _num _myfile
	local menu_list=

	local title=" profile "
	local prompt="${GET_VMPROFILE_MSG}"

	_all=0

	eval $( env NOCOLOR=1 show_profile_list search_profile=${_search_profile} show_${emulator}=1 uniq=1 display=path,name,contrib header=0 |while read path vm_profile contrib; do
		unset long_description
		eval $( ${GREP_CMD} ^long_description= ${path} )
		[ -z "${long_description}" ] && long_description="${vm_profile}"
		[ "${contrib}" = "1" ] && long_description="[contrib] ${long_description}"
		_mypath=$( echo ${path} | /usr/bin/sed s:^${workdir}/::g )
		menu_list="${menu_list} '${vm_profile}' '${_mypath}' '${long_description}'"
		echo "menu_list=\"${menu_list}\""
		# store filename
		echo "profile${_all}=\"${vm_profile}\""
		echo "file${_all}=\"${path}\""
		_all=$(( _all + 1 ))
		echo "_all=${_all}"
	done )

	[ -z "${menu_list}" ] && unset vm_os_profile && return 0

	if [ -n "${1}" ]; then
		mtag="${1}"
		retval=${DIALOG_OK}
	else
		defaultitem="${vm_os_profile}"
		#cbsd_menubox
		extra_label="Update from GIT"
		cbsd_menubox_with_extra_button
		retval=$?
	fi

	case ${retval} in
		${DIALOG_OK})
			pkgnum=0
			unset pkglist tpl_pkglist from_jail vm_profile profile
			alt_iso=
			vm_os_profile="${mtag}"
			_num=0
			_myfile=$( while [ ${_num} -ne ${_all} ]; do
				eval _myfile="\$file${_num}"
				eval _prof="\$profile${_num}"
				[ "${vm_os_profile}" = "${_prof}" ] && echo "${_myfile}" && exit
				_num=$(( _num + 1 ))
			done )

			[ -z "${_myfile}" ] && return 0

			if [ -f "${_myfile}" ]; then
				unset imgsize vm_ram vm_cpus
				. ${_myfile}
				global_profile_file="${_myfile}"
				apply_vm_package
			fi
			;;
		${DIALOG_EXTRA})
			get_profiles_update
			continue
			;;
		*)
			;;
	esac

	vm_iso_path="${register_iso_as}"

	return ${retval}
}

# form for $profile
# if $1 not empty, just load $1 profile without dialogizing
get_construct_profile()
{
	local _input _retval _search_profile="${emulator}-freebsd-" jail_profile _res _myprofiles="" _myfile
	local _old_profile="${profile}"
	local menu_list=

	local defaultitem="${profile}"
	local title=" profile "
	local prompt="${GET_JAILPROFILE_MSG}"

	# default must be first due to last dir with user settings must overwrite
	_res=$( env NOCOLOR=1 show_profile_list show_jail=1 search_profile=${_search_profile} display=path header=0 )

	for i in ${_res}; do
		unset jail_profile
		eval $( ${GREP_CMD} ^jail_profile= ${i} )
		eval $( ${GREP_CMD} ^long_description= ${i} )
		_mypath=$( echo ${i} | /usr/bin/sed s:^${workdir}/::g )
		menu_list="${menu_list} '${jail_profile}' '${_mypath}' '${long_description}'"
		#store filename
		local file_${jail_profile}="${i}"
	done

	[ -z "${menu_list}" ] && unset jail_profile && return 0

	# unset for previous template package list
	unset tpl_pkglist

	if [ -z "${1}" ]; then
		cbsd_menubox
		case $retval in
			${DIALOG_OK})
				pkgnum=0
				unset pkglist tpl_pkglist from_jail vm_profile profile
				if [ -n "${mtag}" ]; then
					profile="${mtag}"
				else
					profile="${_old_profile}"
				fi
				;;
			*)
				;;
		esac
	else
		profile="${1}"
	fi

	eval _myfile="\$file_$profile"

	if [ -f "${_myfile}" ]; then
		. ${_myfile}
		global_profile_file="${_myfile}"
		# reload some dynamic variables depended from jname
		if [ -f ${etcdir}/${zero_profile} ]; then
			merge_apply_profiles ${global_profile_file} ${etcdir}/${zero_profile}
			merge_apply_profiles ${etcdir}/${zero_profile} ${_myfile}
		else
			merge_apply_profiles ${global_profile_file} ${etcdir}/defaults/${zero_profile}
			merge_apply_profiles ${etcdir}/defaults/${zero_profile} ${_myfile}
		fi
	fi

	# populate pkglist from tpl_pkglist if not empty
	if [ -n "${tpl_pkglist}" ]; then
		if [ -r "${tpl_pkglist}" ]; then
			# its file
			pkglist="${tpl_pkglist}"
		else
			pkglist="${ftmpdir}/tui.$$"
			trap "/bin/rm -f ${pkglist}" HUP INT ABRT BUS TERM EXIT
			for _i in ${tpl_pkglist}; do
				echo ${_i} >> ${pkglist}
			done
		fi
	fi

	return ${retval}
}


# form for $gw4
get_construct_gw4()
{
	local _input

	f_dialog_title " gw4 "

	f_dialog_input _input "${GET_GW4_MSG}" "${gw4}" \
			"${_message}" || return $?
	
	gw4="${_input}"
}


# form for $nodename
get_construct_nodename()
{
	title=" nodename "
	prompt="${nodename_msg}"
	defaultitem="${nodename}"

	cbsd_inputbox_simple && nodename="${mtag}"
}

# form for $jdomain
get_construct_jdomain()
{
	title=" jdomain "
	prompt="${jdomain_msg}"
	defaultitem="${jdomain}"

	cbsd_inputbox_simple && jdomain="${mtag}"
}


make_bhyve_part()
{
/bin/cat >> ${TMPFILE} << EOF
exec_start="${exec_start}"
exec_stop="${exec_stop}"
emulator="bhyve";
imgsize="${imgsize}";
imgtype="${imgtype}";
vm_cpus="${vm_cpus}";
vm_ram="${vm_ram}";
vm_os_type="${vm_os_type}";
vm_efi="${vm_efi}";

iso_site="${iso_site}";
iso_img="${iso_img}";
register_iso_name="${register_iso_name}"
register_iso_as="${register_iso_as}"

vm_hostbridge="${vm_hostbridge}";
bhyve_flags="${bhyve_flags}";
virtio_type="${virtio_type}";
gw4="${gw4}";
vm_os_profile="${vm_os_profile}";
jprofile="${jprofile}";
swapsize="${swapsize}";
vm_iso_path="${register_iso_as}";
vm_guestfs="${vm_guestfs}";
vm_vnc_port="${vm_vnc_port}";

bhyve_generate_acpi="${bhyve_generate_acpi}";
bhyve_wire_memory="${bhyve_wire_memory}";
bhyve_rts_keeps_utc="${bhyve_rts_keeps_utc}";
bhyve_force_msi_irq="${bhyve_force_msi_irq}";
bhyve_x2apic_mode="${bhyve_x2apic_mode}";
bhyve_mptable_gen="${bhyve_mptable_gen}";
bhyve_ignore_msr_acc="${bhyve_ignore_msr_acc}";

cd_vnc_wait="${cd_vnc_wait}";
bhyve_vnc_resolution="${bhyve_vnc_resolution}";
bhyve_vnc_tcp_bind="${bhyve_vnc_tcp_bind}";
bhyve_vnc_vgaconf="${bhyve_vnc_vgaconf}";

with_img_helpers="";
runasap="${runasap}";
nic_driver="${nic_driver}";

vnc_password='${vnc_password}';

media_auto_eject="${media_auto_eject}";
vm_cpu_topology="${vm_cpu_topology}";
debug_engine="${debug_engine}";
xhci="${xhci}";
EOF
}


make_virtualbox_part()
{
/bin/cat >> ${TMPFILE} << EOF
exec_start="${exec_start}"
exec_stop="${exec_stop}"
emulator="${emulator}";
imgsize="${imgsize}";
vm_cpus="${vm_cpus}";
vm_ram="${vm_ram}";
vm_os_type="${vm_os_type}";
vm_efi="${vm_efi}";

iso_site="${iso_site}";
iso_img="${iso_img}";
register_iso_name="${register_iso_name}"
register_iso_as="${register_iso_as}"

vm_hostbridge="${vm_hostbridge}";
bhyve_flags="${bhyve_flags}";
virtio_type="${virtio_type}";
gw4="${gw4}";
vm_os_profile="${vm_os_profile}";
jprofile="${jprofile}";
swapsize="${swapsize}";
vm_guestfs="${vm_guestfs}";
vm_vnc_port="${vm_vnc_port}";
with_img_helpers="";
runasap="${runasap}";
EOF
}

make_xen_part()
{
/bin/cat >> ${TMPFILE} << EOF
exec_start="${exec_start}"
exec_stop="${exec_stop}"
emulator="xen";
imgsize="${imgsize}";
vm_cpus="${vm_cpus}";
vm_ram="${vm_ram}";
vm_os_type="${vm_os_type}";
vm_efi="${vm_efi}";

iso_site="${iso_site}";
iso_img="${iso_img}";
register_iso_name="${register_iso_name}"
register_iso_as="${register_iso_as}"

virtio_type="${virtio_type}";
gw4="${gw4}";
vm_os_profile="${vm_os_profile}";
jprofile="${jprofile}";
swapsize="${swapsize}";
vm_iso_path="${register_iso_as}";
vm_guestfs="${vm_guestfs}";
vm_vnc_port="${vm_vnc_port}";

cd_vnc_wait="${cd_vnc_wait}";
xen_vnc_resolution="${xen_vnc_resolution}";
xen_vnc_tcp_bind="${xen_vnc_tcp_bind}";

with_img_helpers="";
runasap="${runasap}";
nic_driver="${nic_driver}";

vnc_password='${vnc_password}';
EOF
}

make_emulator_part()
{
	${SYSRC_CMD} -qf ${TMPFILE} exec_start="/usr/local/bin/${emulator} ${exec_start}" > /dev/null 2>&1
	${SYSRC_CMD} -qf ${TMPFILE} exec_stop="/usr/local/bin/${emulator} ${exec_stop}" > /dev/null 2>&1
}

make_jail_part()
{
	${SYSRC_CMD} -qf ${TMPFILE} exec_start="${exec_start}" > /dev/null 2>&1
	${SYSRC_CMD} -qf ${TMPFILE} exec_stop="${exec_stop}" > /dev/null 2>&1
}

# generate temp .jconf
gen_jconf()
{
	local TMPFILE="${ftmpdir}/${jname}.$$.jconf"
	local fstab="${jailfstabdir}/${jailfstabpref}${jname}"
	local rcconf="${jailrcconfdir}/rc.conf_${jname}"

	# original jail area
	/bin/cat > ${TMPFILE} << EOF
# DO NOT EDIT THIS FILE. PLEASE USE INSTEAD:
# cbsd jconfig jname=${jname}
relative_path="1";
jname="${jname}";
path="${path}";
host_hostname="${host_hostname}";
ip4_addr="${ip4_addr}";
mount_devfs="${mount_devfs}";
allow_mount="${allow_mount}";
allow_devfs="${allow_devfs}";
allow_nullfs="${allow_nullfs}";
allow_fusefs="${allow_fusefs}";
allow_raw_sockets="${allow_raw_sockets}";
mount_fstab="${fstab}";
arch="${arch}";
mkhostsfile="${mkhostsfile}";
devfs_ruleset="${devfs_ruleset}";
ver="${ver}";
basename="${basename}";
baserw="${baserw}";
allow_raw_sockets="${allow_raw_sockets}";
mount_src="${mount_src}";
mount_obj="${mount_obj}";
mount_kernel="${mount_kernel}";
mount_ports="${mount_ports}";
astart="${astart}";
data="${data}";
vnet="${vnet}";
nic_hwaddr="${nic_hwaddr}";
applytpl="${applytpl}";
mdsize="${mdsize}";
rcconf="${jailrcconfdir}/rc.conf_${jname}";
floatresolv="${floatresolv}";
zfs_snapsrc="${zfs_snapsrc}";

exec_poststart="${exec_poststart}";
exec_poststop="${exec_portstop}";
exec_prestart="${exec_prestart}";
exec_prestop="${exec_prestop}";

exec_master_poststart="${exec_master_poststart}";
exec_master_poststop="${exec_master_poststop}";
exec_master_prestart="${exec_master_prestart}";
exec_master_prestop="${exec_master_prestop}";
pkg_bootstrap="${pkg_bootstrap}";
with_img_helpers="";
runasap="${runasap}";
allow_reserved_ports="${allow_reserved_ports}";

persist="${persist}";
childrenmax="${childrenmax}";
enforce_statfs="${enforce_statfs}";

EOF

	[ -n "${interface}" ] && /bin/cat >> ${TMPFILE} <<EOF
interface="${interface}";
EOF


	[ -n "${jailskeldir}" ] && /bin/cat >> ${TMPFILE} <<EOF
jailskeldir="${jailskeldir}";
EOF

	[ -n "${customskel}" ] && /bin/cat >> ${TMPFILE} <<EOF
customskel="${customskel}";
EOF

	[ -n "${jailsysskeldir}" ] && /bin/cat >> ${TMPFILE} <<EOF
jailsysskeldir="${jailsysskeldir}";
EOF

	if [ -z "${profile}" ]; then
/bin/cat >> ${TMPFILE} <<EOF
jail_profile="default";
EOF
		else
/bin/cat >> ${TMPFILE} <<EOF
jail_profile="${profile}";
EOF
	fi

	# additional area
	[ -n "${user_pw_root_crypt}" ] && /bin/cat >> ${TMPFILE} <<EOF
# root password
user_pw_root_crypt='${user_pw_root_crypt}';
EOF

	[ -n "${user_pw_root}" ] && /bin/cat >> ${TMPFILE} <<EOF
# root password
user_pw_root='${user_pw_root}';
EOF

	[ -n "${pkglist}" ] && echo "pkglist=\"${pkglist}\";" >> ${TMPFILE}

	if [ -n "${srvlist}" -a -r "${srvlist}" ]; then
		/bin/cat ${srvlist} >> ${TMPFILE}
		/bin/rm -f ${srvlist}
	fi

	if [ -n "${adduser}" -a -r "${adduser}" ]; then
		/bin/cat ${adduser} >> ${TMPFILE}
		/bin/rm -f ${adduser}
	fi
	# end of additional area

#	${SYSRC_CMD} -qf ${TMPFILE} exec_start="${exec_start}" > /dev/null 2>&1
#	${SYSRC_CMD} -qf ${TMPFILE} exec_stop="${exec_stop}" > /dev/null 2>&1

	if [ -n "${alt_iso}" ]; then
		iso_site=
		iso_img=
		register_iso_name=
		register_iso_as="${alt_iso}";		# vm_os_path
	fi

	case "${emulator}" in
		bhyve)
			make_bhyve_part
			getyesno "Do you want to create vm immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd bcreate jconf=${TMPFILE}${NORMAL}"
			bcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		virtualbox)
			make_virtualbox_part
			getyesno "Do you want to create vm immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd vcreate jconf=${TMPFILE}${NORMAL}"
			vcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		xen)
			make_xen_part
			getyesno "Do you want to create vm immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd xcreate jconf=${TMPFILE}${NORMAL}"
			xcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		jail)
			make_jail_part
			echo "emulator=\"${emulator}\"" >> ${TMPFILE}
			getyesno "Do you want to create jail immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd jcreate jconf=${TMPFILE}${NORMAL}"
			jcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		qemu-arm-static|qemu-mips64-static|qemu-aarch64-static)
			make_emulator_part
			echo "emulator=\"${emulator}\"" >> ${TMPFILE}
			getyesno "Do you want to create jail immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd jcreate jconf=${TMPFILE}${NORMAL}"
			jcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		*)
			err 1 "${MAGENTA}Unsupported emulator type: ${GREEN}${emulator}${NORMAL}"
			;;
	esac

	return 0
}


merge_apply_profiles()
{
	local _out
	[ -z "${1}" ] && return 0

	local _orig="$1"; shift
	local _custom="$1"; shift
	local _i

	[ ! -f "${_orig}" ] && return 0
	if [ ! -f "${_custom}" ]; then
		. ${_orig}
		return 0
	fi

	_out=$( /usr/bin/mktemp )

	merge from=${_orig} to=${_custom} out=${_out}

	. ${_out}
	/bin/rm -f ${_out}

}

# invert boolean value for \$$1
# example: invert_checkbox $astart
invert_checkbox()
{
	[ -z "${1}" ] && return 1

	eval _mytest=\$$1
	if [ "${_mytest}" = "1" ]; then
		export ${1}=0
	else
		export ${1}=1
	fi
	continue
}

# form for $nic_hwaddr
get_construct_nic_hwaddr()
{
	. ${workdir}/vnet.subr	# ip2mac

	local tpl_ip

	if [ -n "${ip4_addr}" ]; then
		ipwmask ${ip4_addr}
		iptype ${IWM}
		if [ $? -ne 0 ]; then
			tpl_ip="${IWM}"
		else
			tpl_ip="123.234.254.192"	# random IP
		fi
	else
		tpl_ip="123.234.254.192"	# random IP
	fi

	local _input
	local _defhwaddr=$( ip2mac ${tpl_ip} )

	f_dialog_title " NIC hwaddr "

	[ -n "${nic_hwaddr}" ] && new_defhwaddr="${nic_hwaddr}"

	f_dialog_input _input "Input MAC address ( 0 - random ), eg: ${_defhwaddr}" "${new_defhwaddr}" \
		"${_message}" || return $?

	# todo: scan for dup

	[ -n "${_input}" ] && nic_hwaddr="${_input}"
}

# form for $nic_mtu
get_construct_nic_mtu()
{
	local _input

	f_dialog_title " NIC MTU. 0 - auto, inherits parent MTU "

	[ -n "${nic_hwaddr}" ] && new_defhwaddr="${nic_hwaddr}"

	f_dialog_input _input "Input MTU size ( 0 - auto ), eg: 0, 1500, 9000" "${nic_mtu}" \
		"${_message}" || return $?

	[ -n "${_input}" ] && nic_mtu="${_input}"
}

###
fi
