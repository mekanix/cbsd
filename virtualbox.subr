if [ ! "$_CBSD_VIRTUALBOX_SUBR" ]; then
_CBSD_VIRTUALBOX_SUBR=1
###

# generic function for virtualbox
# required:
# strings.subr
#

. ${distdir}/virtual.subr

VBOX_CMD="/usr/local/bin/VirtualBox"
VBOX_MGMT_CMD="/usr/local/bin/VBoxManage"
VBOX_HEADLESS_CMD="/usr/local/bin/VBoxHeadless"

# test environment for virtualboxing
# init tmuxcmd
init_virtualbox()
{
	local _required_kmods="vboxdrv vboxnetadp" _i _res

	[ ! -x ${VBOX_CMD} ] && err 1 "${N1_COLOR}No such ${VBOX_CMD}. Please install it: ${N2_COLOR}pkg install virtualbox-ose${N0_COLOR}"

	for _i in ${_required_kmods}; do
		if ! /sbin/kldstat -qm ${_i} >/dev/null 2>&1; then
			${ECHO} "${N1_COLOR}No kldloaded module: ${N2_COLOR}${_i}${N0_COLOR}"
			${ECHO} "${N1_COLOR}Put ${N2_COLOR}kld_list=\"vboxdrv vboxnetadp\"${N1_COLOR} into your ${N2_COLOR}/etc/rc.conf${N1_COLOR} and execute: ${N2_COLOR}service kld restart${N1_COLOR} or load modules via loader.conf and try again.${N0_COLOR}"
			${ECHO} "${N1_COLOR}Make sure you have vboxnet loaded. Execute:${N0_COLOR}"
			${ECHO} "${N2_COLOR}sysrc vboxnet_enable=\"YES\"${N1_COLOR}"
			${ECHO} "${N1_COLOR}And restart vboxnet:${N1_COLOR}"
			${ECHO} "${N2_COLOR}service vboxnet restart${N0_COLOR}"
			[ -n "${DIALOG}" ] && read p
			exit 0
		fi
	done

	tmuxcmd=$(which tmux)
	[ -z "${tmuxcmd}" ] && err 1 "${N1_COLOR}Current version required for ${N2_COLOR}tmux${N1_COLOR}\nPlease ${N2_COLOR}pkg install tmux ${N1_COLOR} or ${N2_COLOR}make -C /usr/ports/sysutils/tmux install${N1_COLOR} it.${N0_COLOR}"
}


# autoincement for $virtualbox_pci_index variable which symbolizes pci id bus
next_pci_id()
{
	[ -z "${virtualbox_pci_index}" ] && virtualbox_pci_index="0"
	virtualbox_pci_index=$(( virtualbox_pci_index + 1 ))
	[ ${virtualbox_pci_index} -gt 31 ] && ${ECHO} "${N1_COLOR}No free available virtualbox_pci_index, 31 is max${N0_COLOR}" && return 1
	return 0
}

# export arguments for virtualbox about dsk vms in $dsk_args variable
# $jname must be set's
# sample:
# jname="debian"
# if compile_dsk_args; then
# 	echo $dsk_args
# else
#	echo "No disks"
# fi
compile_dsk_args()
{
	local dsk_id=0
	local sqldelimer=" "

	eval $( cbsdsqlro local SELECT dsk_controller,dsk_path,dsk_slot FROM virtualboxdsk WHERE jname=\"${jname}\" AND dsk_type=\"vhd\" |while read dsk_controller dsk_path dsk_slot; do
		if ! next_pci_id; then
			# no free pci bus
			exit 0
		fi

		if [ ${dsk_slot} -eq 0 ]; then
			pcislot=${virtualbox_pci_index}
		else
			pcislot=${dsk_slot}
		fi
		echo "export dsk${dsk_id}=\"-s ${pcislot}:0,${dsk_controller},${data}/${dsk_path}\" ;"
		dsk_id=$(( dsk_id + 1 ))
	done ) || err 1 "${N1_COLOR}Error while create disk map${N0_COLOR}"

	dsk_args=""
	for i in $(seq 0 31); do
		eval T="\$dsk$i"
		[ -z "${T}" ] && break
		# make custom argument for virtualbox and add count to bhive_pci_index cause increment in while loop we lose
		if ! next_pci_id; then
			# no free pci bus
		fi
		dsk_args="${dsk_args} ${T}"
	done

	[ -z "${dsk_args}" ] && return 1
	return 0
}

# print 5c:f9:dd:76:d5:c4 from 5cf9dd76d5c4
normalize_nic_hwaddr()
{
	local _hwaddr
	[ -z "${1}" ] && return 0
	
	_hwaddr=$( echo "${1}" |tr -d ":"| sed -e 's/\([0-9A-Fa-f]\{2\}\)/\1:/g' -e 's/\(.*\):$/\1/' )
	printf ${_hwaddr}
}


# export arguments for virtualbox about nic vms in $nic_args variable
# $jname must be set's
# sample:
# jname="debian"
# if compile_nic_args; then
# 	echo $nic_args
# else
#	echo "No nic"
# fi
compile_nic_args()
{
	local _id=0 i _res taplist=
	local sqldelimer=" "
	local mybridge

	eval $( cbsdsqlro local SELECT id,nic_order,nic_driver,nic_slot,nic_type,nic_parent,nic_hwaddr FROM virtualboxnic WHERE jname=\"${jname}\" |while read nic_id nic_order nic_driver nic_slot nic_type nic_parent nic_hwaddr; do

		if ! next_pci_id; then
			# no free pci bus
			exit 0
		fi

		if [ ${nic_slot} -eq 0 ]; then
			pcislot=${virtualbox_pci_index}
		else
			pcislot=${nic_slot}
		fi

		# when ip=0 and interface=auto we must use default interface for upstream
		if [ "${nic_parent}" = "0" -o "${nic_parent}" = "auto" ]; then
			interface=$( getnics-by-ip ip=0.0.0.0 )
		else
			interface="${nic_parent}"
		fi

		if ! mybridge=$( get_my_device bridge ${interface} ); then
			err 1 "${N1_COLOR}Error: Cant get_my_device for ${interface}: ${mybridge}${N0_COLOR}"
		fi

		mytap=$( get_my_tap ${mybridge} )
		[ $? -eq 1 ] && err 1 "${N1_COLOR}Error: Cant get_my_tap by: ${N2_COLOR}${mybridge}${N0_COLOR}"

		/sbin/ifconfig ${mytap} description "${jname}-nic${_id}" group vm-port up
		_res=$( /sbin/ifconfig ${mybridge} addm ${interface} addm ${mytap} >/dev/null 2>&1 )

		if [ "${nic_hwaddr}" != "0" ]; then
			unset mymac
			mymac=$( normalize_nic_hwaddr ${nic_hwaddr} )
			echo "export nic${_id}=\"-s ${pcislot}:0,virtio-net,${mytap},mac=${mymac}\" ;"
		else
			echo "export nic${_id}=\"-s ${pcislot}:0,virtio-net,${mytap}\" ;"
		fi
		
		echo "export mytap${_id}=\"${mytap}\";"
		
		_id=$(( _id + 1 ))
	done ) || err 1 "${N1_COLOR}Error while create nic map${N0_COLOR}"

	nic_args=""

	for i in $( /usr/bin/seq 0 31 ); do
		eval T="\$nic$i"
		eval taplist="\$mytap$i"
		[ -z "${T}" ] && break
		[ -z "${taplist}" ] && break
		# make custom argument for virtualbox and add count to bhive_pci_index cause increment in while loop we lose
		if ! next_pci_id; then
			# no free pci bus
		fi
		nic_args="${nic_args} ${T}"
		mytap="${taplist}"
	done

	[ -z "${nic_args}" ] && return 1

	return 0
}


# export arguments for virtualbox hostbridge_args
compile_hostbridge_args()
{
	# This is usually configured at slot 0
	hostbridge_args="-s 0:0,${vm_hostbridge}"
}

# export arguments for virtualbox lpc_args
compile_lpc_args()
{
	if ! next_pci_id; then
		return 1
	fi

	lpc_args="-s ${virtualbox_pci_index}:0,lpc"
}

# export arguments for virtualbox virtio-rnd
compile_virtiornd_args()
{
	# this is feature of FreeBSD 10.1+
	[ ${freebsdhostversion} -lt 1000730 ] && return 0

	if ! next_pci_id; then
		return 1
	fi

	virtiornd_args="-s ${virtualbox_pci_index}:0,virtio-rnd"
}

# export arguments for virtualbox cd_args
# $iso_img must be present
compile_cd_args()
{
	if ! next_pci_id; then
		return 1
	fi

	[ -z "${iso_img}" -o ! -f "${iso_img}" ] && return 1

	cd_args="-s ${virtualbox_pci_index}:0,ahci-cd,${iso_img}"
}

# create new disk image for virtualbox VMs
# $1 full path
# $2 size (eg: 1g)
# require: /usr/local/bin/cbsd as shell
# require: ${tools}
#
# if ! virtualbox_create_dsk /tmp/olala.vhd 10g; then
#    echo ";=("
# fi
virtualbox_create_dsk()
{
	local newdsk="${1}"; shift
	local imgsize="${1}"; shift

	local convval imgbytes blockcount

	if [ -f "${newdsk}" ]; then
		echo "Disk ${newdsk} already exist"
		return 1
	fi

	# test for human
	if is_number ${imgsize}; then
		conv2bytes ${imgsize} || err 1 "${N1_COLOR}conv2bytes from virtualbox.subr error for: ${N2_COLOR}${imgsize}${N0_COLOR}"
		imgbytes="${convval}"
	else
		imgbytes=$imgsize
	fi

	${VBOX_MGMT_CMD} createhd --filename ${newdsk} --sizebyte ${imgbytes}

	return 0
}

# detach and remove disk image from virtualbox VMs
# jname must be set
# $1 dsk_path from sql table (eg: dsk1.vhd )
# require: /usr/local/bin/cbsd as shell
virtualbox_remove_dsk()
{
	local dsk="${1}"; shift
	[ -z "${jname}" -o -z "${dsk}" ] && return 0

	cbsdsqlrw local DELETE FROM virtualboxdsk WHERE dsk_path=\"${dsk}\" AND jname=\"${jname}\"
	[ -f "${data}/${dsk}" ] && rm -f "${data}/${dsk}"

	return 0
}

# detach and remove NIC from virtualbox VMs
# jname must be set
# $1 is id of nic in SQL table
# require: /usr/local/bin/cbsd as shell
virtualbox_remove_nic()
{
	local id="${1}"; shift
	[ -z "${jname}" -o -z "${id}" ] && return 0

	cbsdsqlrw local DELETE FROM virtualboxnic WHERE id=\"${id}\" AND jname=\"${jname}\"

	return 0
}

###
fi
